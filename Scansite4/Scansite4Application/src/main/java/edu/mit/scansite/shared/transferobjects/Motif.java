package edu.mit.scansite.shared.transferobjects;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import com.google.gwt.user.client.rpc.IsSerializable;

import edu.mit.scansite.shared.ScansiteConstants;
import edu.mit.scansite.shared.util.ScansiteScoring;

/**
 * @author Tobieh
 * @author Konstantin Krismer
 */
public class Motif extends LightWeightMotif implements IsSerializable {
    public static final char MOTIF_INFO_ID_SPLITTER = '/'; //only used in a comment

    private static final int WINDOW_SIZE = ScansiteConstants.WINDOW_SIZE;
    private static final double DEFAULT_MATRIX_VALUE = ScansiteConstants.DEFAULT_MATRIX_VALUE;
    private static final double DEFAULT_MATRIX_VALUE_TERMINALS = ScansiteConstants.DEFAULT_MATRIX_VALUE_TERMINALS;
    private static final String TO_STRING_SPACER = "\t";
    private static final int CHAR_INDICES_SIZE = 256;

    private AminoAcid aminoAcidArray[] = AminoAcid.values();
    private HashMap<AminoAcid, Integer> indices = new HashMap<AminoAcid, Integer>(); // indices in aas-array
    private int[] charIndices = new int[CHAR_INDICES_SIZE];
    private double matrix[][] = new double[WINDOW_SIZE][]; // access: matrix[0<position<WINDOW_SIZE][indices.get(aminoAcid)]

    private double optimalScore = -1;
    private int degeneratePositionsCount = -1;
    private ArrayList<AminoAcid> fixedCenters = null;
    private List<Identifier> identifiers = new LinkedList<>();
    private boolean isPublic;
    private LightWeightMotifGroup group;

    private ArrayList<Character> charFixedCenters = null;

    private String submitter;

    public Motif() {
        initWithDefaults();
    }

    /**
     * Creates a motif from a String that is produced by another motif's
     * toString method.
     *
     * @param motifString A String generated by another motif's toString method.
     */
    public Motif(String motifString) {
        this();
        createMotifFromString(motifString);
    }

    /**
     * Resets the motif's values for fixedCenters, degenerateCount, and optimal
     * score. Usually this method has to be called, if these numbers have
     * already been calculated, but some of the motif's position's values have
     * changed!
     */
    public void resetNumbers() {
        fixedCenters = null;
        degeneratePositionsCount = -1;
        optimalScore = -1;
    }

    /**
     * Creates a motif from a String that is produced by another motif's
     * toString method.
     *
     * @param motifString A String generated by another motif's toString method.
     */
    private void createMotifFromString(String motifString) {
        if (motifString != null) {
            String lines[] = motifString.trim().split("\n");
            if (lines.length == WINDOW_SIZE + 1) {
                String aaLine[] = lines[0].trim().split(TO_STRING_SPACER);
                HashMap<Integer, AminoAcid> idx2Aa = new HashMap<Integer, AminoAcid>();
                for (int i = 0; i < aaLine.length; ++i) {
                    idx2Aa.put(i, AminoAcid.getValue(aaLine[i]));
                }

                for (int row = 1; row < WINDOW_SIZE + 1; ++row) {
                    String valLine[] = lines[row].trim()
                            .split(TO_STRING_SPACER);
                    for (int aaPos = 0; aaPos < valLine.length; ++aaPos) {
                        setValue(idx2Aa.get(aaPos), row - 1,
                                Double.valueOf(valLine[aaPos]));
                    }
                }
            }
        }
        applyFixedCenters();
    }

    /**
     * Initializes the indices-map and the matrix itself.
     */
    private void initWithDefaults() {
        // init indices map
        for (int i = 0; i < aminoAcidArray.length; ++i) {
            indices.put(aminoAcidArray[i], i);
        }
        // init matrix with defaults
        for (int i = 0; i < WINDOW_SIZE; ++i) {
            matrix[i] = new double[aminoAcidArray.length];
            for (int j = 0; j < aminoAcidArray.length; ++j) {
                matrix[i][j] = (AminoAcid.isTerminal(aminoAcidArray[j])) ?
                        DEFAULT_MATRIX_VALUE_TERMINALS : DEFAULT_MATRIX_VALUE;
            }
        }
        // init charIndices with defaults
        for (int i = 0; i < CHAR_INDICES_SIZE; ++i) {
            charIndices[i] = -1;
        }
        for (AminoAcid aa : aminoAcidArray) {
            char charAa = aa.getOneLetterCode();
            int intAa = (int) charAa;
            if (intAa < 256) {
                charIndices[intAa] = indices.get(aa);
            }
        }
    }

    public double getValue(char aa, int position) {
        return matrix[position][charIndices[(int) aa]];
    }

    public double getValue(AminoAcid aa, int position) {
        return matrix[position][indices.get(aa)];
    }

    public void setValue(AminoAcid aa, int position, double value) {
        matrix[position][indices.get(aa)] = value;
    }

    public int getDegeneratePositionsCount() {
        if (degeneratePositionsCount == -1) {
            ScansiteScoring scoring = new ScansiteScoring();
            scoring.calculateOptimalScore(this);
        }
        return degeneratePositionsCount;
    }

    public double getOptimalScore() {
        if (optimalScore == -1) {
            ScansiteScoring scoring = new ScansiteScoring();
            scoring.calculateOptimalScore(this);
        }
        return optimalScore;
    }

    public AminoAcid[] getAminoAcidArray() {
        return aminoAcidArray;
    }

    public void setOptimalScore(double optScore) {
        this.optimalScore = optScore;
    }

    public void setDegeneratePositionsCount(int degeneratePositionsCount) {
        this.degeneratePositionsCount = degeneratePositionsCount;
    }

    public ArrayList<AminoAcid> getFixedCenters() {
        if (fixedCenters == null) {
            applyFixedCenters();
        }
        return fixedCenters;
    }

    private void applyFixedCenters() {
        fixedCenters = new ArrayList<AminoAcid>();
        final int centerIndex = ScansiteConstants.WINDOW_CENTER_INDEX;
        for (AminoAcid aa : AminoAcid.values()) {
            ScansiteScoring scoring = new ScansiteScoring();
            if (scoring.isFixedSite(getValue(aa, centerIndex))) {
                fixedCenters.add(aa);
            }
        }
    }

    @Override
    public String toString() {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < aminoAcidArray.length; ++i) {
            if (i > 0) {
                sb.append(TO_STRING_SPACER);
            }
            sb.append(aminoAcidArray[i]);
        }
        sb.append('\n');
        for (int row = 0; row < WINDOW_SIZE; ++row) {
            for (int aaPos = 0; aaPos < aminoAcidArray.length; ++aaPos) {
                if (aaPos > 0) {
                    sb.append(TO_STRING_SPACER);
                }
                sb.append(matrix[row][aaPos]);
            }
            sb.append('\n');
        }
        return sb.toString();
    }

    public List<Identifier> getIdentifiers() {
        return identifiers;
    }

    public void setIdentifiers(List<Identifier> identifiers) {
        this.identifiers = identifiers;
    }

    public boolean isPublic() {
        return isPublic;
    }

    public void setPublic(boolean isPublic) {
        this.isPublic = isPublic;
    }

    public void setGroup(LightWeightMotifGroup group) {
        this.group = group;
    }

    public LightWeightMotifGroup getGroup() {
        return group;
    }

    public void setSubmitter(String userEmail) {
        this.submitter = userEmail;
    }

    public String getSubmitter() {
        return submitter;
    }

    public synchronized ArrayList<Character> getFixedCentersAsCharacters() {
        if (charFixedCenters == null) {
            charFixedCenters = new ArrayList<Character>();
            for (AminoAcid aa : getFixedCenters()) {
                charFixedCenters.add(aa.getOneLetterCode());
            }
        }
        return charFixedCenters;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + super.getId();
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj != null && obj instanceof Motif) {
            Motif other = (Motif) obj;
            return super.getId() == other.getId();
        } else {
            return false;
        }
    }
}
